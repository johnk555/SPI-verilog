SPI Architecture and Module Description

This document describes the Serial Peripheral Interface (SPI) communication protocol and the specific Verilog HDL modules implemented for a basic SPI Master-Slave system.

1.  SPI (Serial Peripheral Interface) Overview

    SPI is a synchronous serial data protocol widely used for short-distance, single-master, multiple-slave communication. It operates in full-duplex mode, meaning data can be sent and received simultaneously.

    Key characteristics of SPI:
    * **Synchronous:** Communication is synchronized by a shared clock signal (SCLK).
    * **Full-Duplex:** Data can be transmitted and received concurrently.
    * **Master-Slave Architecture:** One master device controls the communication, and one or more slave devices respond.
    * **Four Wires (typically):**
        * **SCLK (Serial Clock):** Generated by the master to synchronize data transfer.
        * **MOSI (Master Out Slave In):** Data line from the master to the slave.
        * **MISO (Master In Slave Out):** Data line from the slave to the master.
        * **SS_n (Slave Select, active low):** Generated by the master to select a specific slave device. When SS_n is low, the slave is active; when high, it's inactive.

    SPI Modes (CPOL and CPHA):
    SPI has four modes, defined by two parameters:
    * **CPOL (Clock Polarity):** Defines the idle state of SCLK (0 = low, 1 = high).
    * **CPHA (Clock Phase):** Defines when data is sampled (0 = on the first clock edge after SS_n goes low, 1 = on the second clock edge).
    The implemented modules are designed for **SPI Mode 0 (CPOL=0, CPHA=0)**, where SCLK is low when idle, and data is sampled on the rising edge and shifted on the falling edge.

2.  Implemented Modules

    The system consists of two primary modules: `spi_master` and `spi_slave`, along with a testbench (`tb_spi`) for verification.

    2.1. `spi_master` Module

    The `spi_master` module controls the SPI bus and initiates data transfers.

    **Inputs:**
    * `clk`: System clock.
    * `rst_n`: Asynchronous reset (active low).
    * `tx_data [7:0]`: 8-bit data to be transmitted to the slave.
    * `start_transfer`: Pulse signal to initiate a new 8-bit transfer.
    * `miso`: Master In Slave Out data line from the slave.

    **Outputs:**
    * `sclk`: Serial Clock generated by the master.
    * `ss_n`: Slave Select signal (active low).
    * `mosi`: Master Out Slave In data line to the slave.
    * `transfer_done`: Pulse signal indicating the completion of an 8-bit transfer.
    * `rx_data [7:0]`: 8-bit data received from the slave.

    **Internal Logic:**
    * **State Machine:** Manages the transfer sequence through states like IDLE, START_SS, SHIFT_DATA, and END_SS.
    * **SCLK Generation:** Uses a clock divider (`SCLK_DIV_FACTOR`) to generate the SCLK signal from the system clock. SCLK is only active during data transfer.
    * **Data Transmission (MOSI):** Shifts `master_tx_data` out, MSB first, synchronized with SCLK.
    * **Data Reception (MISO):** Captures bits from the `miso` line into an internal `master_rx_data` register, MSB first, synchronized with SCLK.
    * **`ss_n` Control:** Asserts `ss_n` low to select the slave at the beginning of a transfer and de-asserts it high at the end.
    * **`transfer_done` Assertion:** Pulsed high for one clock cycle upon the completion of an 8-bit transfer.
    * **`rx_data` Hold:** The `rx_data` output holds the last received data until a new transfer is initiated, ensuring that the testbench or external logic has sufficient time to sample it.

    2.2. `spi_slave` Module

    The `spi_slave` module responds to the master's commands and transfers data when selected.

    **Inputs:**
    * `clk`: System clock.
    * `rst_n`: Asynchronous reset (active low).
    * `sclk`: Serial Clock from the master.
    * `ss_n`: Slave Select signal from the master.
    * `mosi`: Master Out Slave In data line from the master.
    * `slave_tx_data [7:0]`: 8-bit data to be transmitted back to the master.

    **Outputs:**
    * `miso`: Master In Slave Out data line to the master.
    * `slave_rx_data [7:0]`: 8-bit data received from the master.
    * `data_received`: Pulse signal indicating that data has been fully received from the master.

    **Internal Logic:**
    * **State Machine:** Manages its behavior through states like SLAVE_IDLE, SLAVE_ACTIVE, and SLAVE_COMPLETE.
    * **`ss_n` Detection:** Enters `SLAVE_ACTIVE` when `ss_n` goes low and returns to `SLAVE_IDLE` when `ss_n` goes high.
    * **Data Reception (MOSI):** Shifts bits from the `mosi` line into an internal `slave_shift_reg`, MSB first, synchronized with SCLK.
    * **Data Transmission (MISO):** Drives the `miso` line with bits from `slave_miso_reg` (loaded from `slave_tx_data` at the start of a transfer), MSB first, synchronized with SCLK. When not selected, `miso` is high-impedance (`1'bz`).
    * **`data_received` Assertion:** Pulsed high for one clock cycle when `ss_n` goes high, indicating that the received data is valid.
    * **`slave_rx_data` Commit and `bit_counter` Reset:** `slave_rx_data` is latched with the contents of `slave_shift_reg` and the internal `bit_counter` is reset to 0 precisely when `ss_n` goes high, ensuring the slave is ready for the next transaction.

3.  `tb_spi` (Testbench)

    The `tb_spi` module instantiates both the `spi_master` and `spi_slave` and provides the necessary stimulus for functional verification.

    **Functionality:**
    * Generates a system clock (`clk`) and controls the reset (`rst_n`).
    * Connects the SPI bus signals (`sclk`, `ss_n`, `mosi`, `miso`) between the master and slave instances.
    * Provides `master_tx_data_tb` and `slave_tx_data_tb` values.
    * Asserts `start_transfer_tb` to initiate transfers from the master.
    * Waits for `master_transfer_done_tb` to confirm transfer completion.
    * Uses `$display` to report the received data at the end of each transfer.
    * Includes a `$monitor` task to continuously display key signals for detailed waveform analysis.
    * Incorporates necessary delays between transfers to ensure the slave module has adequate time to reset and prepare for subsequent communications, preventing missed messages.
